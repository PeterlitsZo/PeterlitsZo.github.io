<!DOCTYPE html>
<html>
<head>
<title>LaTeX学习手记06.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/**
 * GitHub Gist Theme
 * Author : Louis Barranqueiro - https://github.com/LouisBarranqueiro
 */

.hljs {
  display: block;
  background: white;
  padding: 0.5em;
  color: #333333;
  overflow-x: auto;
}

.hljs-comment,
.hljs-meta {
  color: #969896;
}

.hljs-string,
.hljs-variable,
.hljs-template-variable,
.hljs-strong,
.hljs-emphasis,
.hljs-quote {
  color: #df5000;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-type {
  color: #a71d5d;
}

.hljs-literal,
.hljs-symbol,
.hljs-bullet,
.hljs-attribute {
  color: #0086b3;
}

.hljs-section,
.hljs-name {
  color: #63a35c;
}

.hljs-tag {
  color: #333333;
}

.hljs-title,
.hljs-attr,
.hljs-selector-id,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #795da3;
}

.hljs-addition {
  color: #55a532;
  background-color: #eaffea;
}

.hljs-deletion {
  color: #bd2c00;
  background-color: #ffecec;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///home/peterlits/Git_Item/PeterlitsZo.github.io/css%20source/markdown.css" type="text/css">
</head>
<body>
<h1 id="latex%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B006">LaTeX学习手记06</h1>
<h2 id="%E6%AD%A3%E6%96%87">正文</h2>
<p>上一章全是讲得nodes，是很重要啦，但是这一节可能会更重要一些。</p>
<h4 id="%E5%87%A0%E4%BD%95%E7%94%BB%E5%9B%BE">几何画图</h4>
<p>这一次使用的包是<code>clac, intersections, through, backgroud</code>。</p>
<p>首先是一条蓝色的线AB：</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">{tikzpicture}</span></span>
    <span class="hljs-tag">\<span class="hljs-name">coordinate</span></span> [label=left:<span class="hljs-tag">\<span class="hljs-name">textcolor</span><span class="hljs-string">{blue}</span><span class="hljs-string">{$A$}</span></span>]  (A) at (0,0);
    <span class="hljs-tag">\<span class="hljs-name">coordinate</span></span> [label=right:<span class="hljs-tag">\<span class="hljs-name">textcolor</span><span class="hljs-string">{blue}</span><span class="hljs-string">{$B$}</span></span>] (B) at (1.25,0.25);

    <span class="hljs-tag">\<span class="hljs-name">draw</span><span class="hljs-string">[blue]</span></span> (A)--(B);
<span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">{textpicture}</span></span>
</div></code></pre>
<p>然后以A 为圆心，AB 为半径，作一个圆：（方法一）</p>
<pre class="hljs"><code><div><span class="hljs-comment">% use library clac</span>
<span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">{tikzpicture}</span></span>
    <span class="hljs-tag">\<span class="hljs-name">coordinate</span></span> [label=left:<span class="hljs-formula">$A$</span>]    (A) at (0,0);
    <span class="hljs-tag">\<span class="hljs-name">coordinate</span></span> [label=right:<span class="hljs-formula">$B$</span>]   (B) at (1.25,0.25);
    <span class="hljs-tag">\<span class="hljs-name">draw</span></span> (A)--(B);

    <span class="hljs-tag">\<span class="hljs-name">draw</span></span> (A) let   <span class="hljs-tag">\<span class="hljs-name">p</span></span>1 = (<span class="hljs-formula">$(B) - (A)$</span>)
              in    circle({ veclen(<span class="hljs-tag">\<span class="hljs-name">x</span></span>1,<span class="hljs-tag">\<span class="hljs-name">y</span></span>1) });
<span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">{tikzpicture}</span></span>
</div></code></pre>
<p>let ... in 操作符可以放在path 中间，让一个坐标或者其他结果赋值给多个值。其中，<code>\x&lt;digit&gt;</code> 指x 轴，<code>\y&lt;digit&gt;</code> 指y 轴，<code>\p&lt;digit&gt;</code>指这个坐标。趁势为B 作一个圆：</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">{tikzpicture}</span></span>
    <span class="hljs-tag">\<span class="hljs-name">coordinate</span></span> [label=left:<span class="hljs-formula">$A$</span>]    (A) at (0,0);
    <span class="hljs-tag">\<span class="hljs-name">coordinate</span></span> [label=right:<span class="hljs-formula">$B$</span>]   (B) at (1.25,0.25);
    <span class="hljs-tag">\<span class="hljs-name">draw</span></span> (A)--(B);

    <span class="hljs-tag">\<span class="hljs-name">draw</span></span> let   <span class="hljs-tag">\<span class="hljs-name">p</span></span>1 = (<span class="hljs-formula">$ (B)-(A) $</span>),
                <span class="hljs-tag">\<span class="hljs-name">n</span></span>2 = {veclen(<span class="hljs-tag">\<span class="hljs-name">x</span></span>1,<span class="hljs-tag">\<span class="hljs-name">y</span></span>1)}
          in    (A) circle (<span class="hljs-tag">\<span class="hljs-name">n</span></span>2)
                (B) circle (<span class="hljs-tag">\<span class="hljs-name">n</span></span>2);
<span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">{tikzpicture}</span></span>
</div></code></pre>
<p>其中坐标也可以使用长名称，但是要加大括号<code>\n{radius}</code>。</p>
<h4 id="%E5%85%88%E8%B7%B3%E5%87%BA%E6%9D%A5%EF%BC%8C%E7%9C%8B%E7%9C%8Bnode-%E5%92%8Ccoordinate-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%90%A7">先跳出来，看看node 和coordinate 到底有什么不同吧</h4>
<p>coordinate 本身是the shortcut for <code>\path ... coordinate[&lt;options&gt;](&lt;name&gt;) at (&lt;coordinate&gt;) ...</code>。而它与这个表示的含义相同：<code>node [shape=coordinate] [&lt;options&gt;](&lt;name&gt;) at (&lt;coordinate&gt;) {}</code>。（不过，这里的at part 可以没有）</p>
<p>一般来说，node 会默认建成这三种shape 中的一种：<code>rectangle</code>，<code>circle</code> and <code>coordinate</code>。</p>
<p>总的来说，如果不只是建一个点的话（比如说先要放一个圆圈，设置一个label之类的），用node来表示交点更好，也更抽象。</p>
<h4 id="%E8%81%AA%E6%98%8E%E7%9A%84%E6%88%91%E9%A9%AC%E4%B8%8A%E5%B0%B1%E8%B7%B3%E5%9B%9E%E5%8E%BB%E4%BA%86%EF%BC%81">聪明的我马上就跳回去了！</h4>
<p>通过使用<code>through</code> library 可以创建一个through 过了一个给定点的形状。</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">node</span></span> [draw, circle through = (B), label = left:<span class="hljs-formula">$D$</span>] at (A) {};
<span class="hljs-comment">% $D$是画在圆附近的。</span>
</div></code></pre>
<p>应该是这样的：node 中，使用label 会考虑它的形状的，但是放在<code>{}</code> 中就不会考虑它的形状......是这样吗？</p>
<p>接下来是使用<code>intersections</code> 库来找到两个圆的交点。</p>
<p>两个相交的圆会有两个交点：<code>intersection-1</code> 和<code>intersection-2</code> 而node 的path 圆和node 拥有相同的名字，只是可以看做在不同的<code>namespace</code> 中罢了。</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">node</span></span> (D) [name path=D,draw,circle through=(B),label=left:<span class="hljs-formula">$D$</span>]  at (A) {};
<span class="hljs-tag">\<span class="hljs-name">node</span></span> (E) [name path=E,draw,circle through=(A),label=right:<span class="hljs-formula">$E$</span>] at (B) {};

<span class="hljs-tag">\<span class="hljs-name">path</span></span> [name intersections={of=D and E}];

<span class="hljs-tag">\<span class="hljs-name">coordinate</span></span> [label=above:<span class="hljs-formula">$C$</span>] (C) at (intersection-1);
</div></code></pre>
<p>其中<code>intersections</code> 也提供了可以直接命名的办法：</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">path</span></span> [name intersections={of=D and E, by={[lable=above:<span class="hljs-formula">$C$</span>]C,[label=below:<span class="hljs-formula">$C'$</span>]C'} }];

<span class="hljs-tag">\<span class="hljs-name">draw</span></span> [name path=C--C',red] (C)--(C');
</div></code></pre>
<p>小方法：可以使用<code>\def\...{...}</code> 来定义相关宏。可以使用<code>\colorset</code>来定义相关颜色。</p>
<h4 id="partway-calculations">partway calculations</h4>
<p>可以新建一个点，用<code>($</code>开头，用这个结尾<code>$)</code>,中间包含了<code>!&lt;part&gt;!</code>的partway 运算符来表示。比如新建一个A, B 中点：</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">node</span></span> [fill=red, inner sep=1pt, label=below:<span class="hljs-formula">$X$</span>] (X) at ( <span class="hljs-formula">$(A)!0.5!(B)$</span> ) {};
</div></code></pre>
<p>啊啊啊啊！好棒，partway calculations还可以更改角度（就像rotate一样）！使用形式是<code>( $(A)!&lt;times of AB's part's long&gt;!&lt;angle which begin on A-&gt;B&gt;:(B)$ )</code>。而且这种运算符支持链式结构，可以连成很长一串。</p>
<p>为了找到BF 与圆B的交点，除了使用<code>intersections</code> 之外，还可以使用partway，只要知道了半径的长度。（圆过C 点）</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">path</span></span> let <span class="hljs-tag">\<span class="hljs-name">p</span></span>1 = ( <span class="hljs-formula">$(B)-(C)$</span> ) in
        coordinate [label=left:<span class="hljs-formula">$G$</span>] (G) at ( <span class="hljs-formula">$(B)!veclen(<span class="hljs-tag">\<span class="hljs-name">x</span></span>1,<span class="hljs-tag">\<span class="hljs-name">x</span></span>2)!(F)$</span> );
</div></code></pre>
<p>当然<code>intersections</code> 会显得简单一点。</p>
<pre class="hljs"><code><div><span class="hljs-tag">\<span class="hljs-name">path</span></span> [name path=B--F] (B)--(F);
<span class="hljs-tag">\<span class="hljs-name">path</span></span> [name intersections={ of = H and B--F,by = [label=left:<span class="hljs-formula">$G$</span>]G }];
</div></code></pre>
<h4 id="%EF%BC%88%E5%8E%9F%E6%96%871351%E8%8A%82%EF%BC%89%E9%80%9A%E7%94%A8%E5%8F%A5%E6%B3%95">（原文13.5.1节）通用句法</h4>
<p>通用句法是：<code>( [&lt;options&gt;]$&lt;coordination&gt;$ )</code>其中<code>$</code>表明了被它括住的是一个数学表达式。</p>
<p>而<code>&lt;coordinations&gt;</code>是由<code>&lt;factor&gt;*&lt;coordinate&gt;&lt;modifiers&gt;</code>和加号和减号构成的。</p>
<p>其中 factor 是可选的。对于复杂的 factor 还可以在其前后加上大括号。</p>
<p>而后面的<code>&lt;modifiers&gt;</code>就更加有意思了：（第一种）</p>
<pre class="hljs"><code><div>    &lt;coordinate&gt;!&lt;number&gt;!&lt;angle&gt;:&lt;second coordinate&gt;
</div></code></pre>
<p><code>&lt;angle&gt;</code>是可选的。它表明了对于原点的绕点角度。</p>
<p>让它显得更厉害的是它可以链式使用（虽然不知道哪里用得上它。。。）</p>
<p>第二种形式和第一种差不多，区别在于，第二种可以使用距离而非表示倍数的数。</p>
<p>第三种中，两个感叹号中夹着的是点：</p>
<pre class="hljs"><code><div>    &lt;coordinate&gt;!&lt;projection coordinate&gt;!&lt;angle&gt;:&lt;second coordinate&gt;
</div></code></pre>
<p>它找到的还是两点直线上的点，但是与之不同的是，它是依靠<code>projection coodinate</code>的射影来找的。</p>
<p>用在画垂线这方面，垂点已知用前两种，垂点不知道就用第三种。</p>
<h2 id="%E5%8F%82%E8%80%83">参考</h2>
<ul>
<li>[1]<a href="http://www.texample.net/media/pgf/builds/pgfmanual_3.0.1a.pdf">官方网址</a>，<a href="./resources/pdf/pgfmanual.pdf">镜像(html文档下打开)</a>，<a href="../resources/pdf/pgfmanual.pdf">镜像(md文档下打开)</a></li>
</ul>

</body>
</html>
