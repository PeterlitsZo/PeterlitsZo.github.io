Python语言及其应用01
=====================================
正文
-------------------------------------
语言有动态语言和静态语言之分，静态语言很麻烦，但是写好了之后不仅很有艺术感而且运行得也很快————因为它们是需要编译的，变量类型是不能更改的（这就是他们被叫做静态语言的原因）；动态语言完全就是福音！因为与系统和硬件隔了一层语言内核，抛掉了很多语法包袱，而且一个文件在所有系统上都能运行（还不用编译）。动态语言看起来不是最完整的语言，因为它们之间必须要用内核做翻译工作，可也是这样，它们本身就具有艺术感。越来越多的人会爱上动态语言。因为动态语言有着静态语言永远无法具有的魅力。（当然，作为也浅显学过 C/C++ 的我来说，静态语言也有足够征服人心的魅力————速度和效率，虽然这个很多时候都不是必须的......）

### Python 的基本对象
Python 的基本元素有数字（包括整型和浮点型）、字符串和布尔值。

#### 对象的名字和数据的关系
和静态语言不同，python 的赋值其实是给名字贴上一个引用。（静态语言会先在内存里开辟一个内存块，然后把名字与内存块的地址等值，比如 `int a = 12; a += 12;`代表了先在内存里开辟一个内存块，告诉自己要用 `int` 的方法来处理它，然后在 `a` 对应的地址里的值，加上`12`（用 `int` 的方法））

#### 对象的类型————type()函数
想要知道一个对象的类型，可以使用 `type()`语句：
``` python
>>> a = 12
>>> type(a)
<class 'int'>
>>> type(a)==<class 'int'>
  File "<stdin>", line 1
    type(a)==<class 'str'>
             ^
SyntaxError: invalid syntax
>>> type(a)==type(int)
False
>>> type(a)==int
True
```

根据上面可以知道，`type` 会返回对象的类型。（绕口令警告）而一个类型的类型是类型。比如说 `int` 的类型是 `type`（即类型），有 `type(int)==type`。而值的类型是值的类型：`type(a)==int`。

可以看到根本没有所谓的`<class 'int'>`，只是 `int` 读作它而已：
``` python
>>> int
<class 'int'>
```

### Python 的数字运算符
python 的数字运算有`+`，`-`，`*`，`/`，`//`，`%`，`**`。（因为早就会了不做笔记了）

也像大多数语言一样，可以使用`+=`等等等等的语法来进行运算。

python 是支持二进制的（哇！好棒！）：
- 使用`0b` 或`0B` 来代表二进制。
- 使用`0o` 或`0O` 来代表八进制。
- 使用`0x` 或`0X` 来代表十六进制。

### 类型转换
跟其他语言类似，它可以将其他类型的值进行类型转换：
``` python
>>> int('4')
4
```

#### 扩展：美妙的特性————数字长度与系统无关
但跟其他语言不一样的是，Python 的数字范围不受限制（在其他语言中，数字范围会受内存位数的限制————比如说32位或者64位）

### Python 的基本对象和相关容器
#### 字符串
对于字符串来说，可以使用单引号或者双引号，甚至（为了方便创建多行文本）使用三引号。

对于文本的修改，值得一提的是，Python 根本不会在储存字符的内存中直接修改，而是创建一个新文本，然后更改名字的引用（不能更方便了，但对于对内存习惯斤斤计较的人来说可能不太好————简单胜于复杂，就这样）

字符串中还有转义字符，例如`\n`，`\t` 等等。

和 C++一样，Python 的 str 类型支持加号，也支持不使用加号直接拼贴（末尾可以使用`\`号换行），还支持使用`*`号进行复制，使用`[]`号进行提取。

使用方括号时，除了使用偏移量来抽取字符，还可以用它来切片。
- 对于偏移量，字符串是以`0`开始，以`-1`结尾。
- 对于切片，格式是`[start:end:step]`，切的片包含 `start` 而不包含 `end`，`step` 默认为1，可以为负，其他可以省略。

字符串还支持一系列的值：`len()`，`spilt()`，`join()`，`endswith()`等等等等。可以查看相关的官方文档了解更多的字符串的内容。

#### 列表
python 的容器种类有四种：列表、元组、字典和集合。

对于列表来说，可以使用`[ ]`或者 `list()`来创建列表，列表和元组一样，是支持同时储存不同类型的元素的。
``` python
>>> ['a','b','c']
['a','b','c']
>>> list('abc')
['a','b','c']
```

列表支持嵌套，可以修改列表中的值（虽然原来的值没变，只是引用到了一个新值上了），能用切片，当然也支持很多方法：
- append()：添加元素至尾部。
- extend()：合并列表（或者使用`+=`）。
- insert()：在指定位置插入元素。
- del()：在指定位置删除元素。
- remove()：删除具有指定值的元素。
- pop()：获取并删除指定位置的元素。
- index()：查询具有特定值的元素位置。
- count()：记录特定值出现的位置。
- jion()：jion 是字符串方法。使用它可以来链接字符串列表。
- sort()：重新排列元素。
- len()：获取长度。

列表支持 `in` 操作符：
``` python
>>> words = ['a', 'deer', 'a', 'female', 'deer']
>>> 'deer' in words
True
```

列表和一般的数字不太一样：对列表进行更改后，返回的地址还是原来的地址，而一般的数字更改后返回的却是新的地址。比如说：
``` py
>>> a = [1, 2, 3]
>>> b = a
>>> a.pop()
3
>>> b
[1, 2]
>>> a = 3
>>> b = a
>>> a -= 1
>>> b
2
```

所以如果只是想要一份一个列表的拷贝时，可以使用：
- 列表的方法`.copy()`。
- 初始化列表函数 `list(name_of_list)`。
- 切片 `name_of_list[:]`。

#### 元组
和列表相似但是不同的是，元组是不可变的（虽然不清楚到底是干什么的哈哈哈哈），使用`( )`或者 `tuple()`来初始化（不过 `tuple()` 和 `list()` 一样，只能接受一个迭代器）。使用元组的理由如下：
- 元组占用空间较小。
- 不会意外修改元组的值。
- 可以将它用作字典的值。
- 命名元组可以用作对象的代替。（我也不知道它是什么的说）
- 函数的参数是以元组的形式传递的。

#### 字典
字典与列表类似（哈哈哈哈元组你也是这么说的），与使用偏移量不同的是，字典使用的是互不相同的键（字典是可变的）

使用`{ }`或者 `dict()`来初始化字典，比如说：
``` py
bierce = {
    "day": "A period ... ",
    "positive": "Mistaken at ...",
}
```

如果使用 `dict()`来创造字典，必须要接受一个包含双值子序列的序列。

（可以使用 `zip()`来简单地创造这种序列）

字典有很多方法：
- update()：合并字典（用来合并的字典不受影响）。
- clear()：删除所有元素。
- key()：获取字典中的所有值。（返回的是一个 `dict_keys` 类型的，需要使用 `list()` 来进行类型转换————至少在 Python3中是这样）
- value()：获取所有值。（而且和 `key()`差不多，需要 `list()`）
- items()：获取所有键值对，键值对以元组形式存在。（而且同上）

字典还支持 `del` 来删除指定值的元素（比如说 `del pythons['Marx']`），也支持 `in` 操作符。

关于赋值和复制，其实和列表差不多。

#### 集合
关于集合的创造，可以使用 `set()`或者`{ }`（注意大括号中必须有丶东西，不然就会新建了一个空字典）。

对于集合和字典来说来说，可以使用 `in` 来测试值是否存在，比如说：
``` py
for name, content in dict_drinks.item():
    if 'vokda' in content:
        print( name )
```

需要注意的是，如果不使用`.item()`的话，在字典里迭代的就只是键了。（当然可以使用引用来得到值了啦）

集合有一些奇妙的运算符：
- `&`：and，取交集。
- `|`：or，取并集。
- `-`：取差集，即出现在第一个集合但没有出现在第二个集合中的元素的集合。
- `^`：取异或集，即在两个集合中只出现过一次的元素的集合。
- `<=`：判断子集，即第一个集合是否是第二个集合的子集（即小于等于第二个集合）。（初次之外还有`<`、`>=`、`>`）

参考
--------------------------------------
- \[1] Python 语言及其应用. Bill Lubanovic 著.